Bands tutorial
==============

In this section, we describe how to use Perturbopy to process a Perturbo ``phdisp`` calculation. 

The Perturbo ``phdisp`` calculation interpolates the phonon dispersion by Fourier transforming real-space interatomic force constants. The first step is to run Perturbo with ``calc_mode`` = ``'phdisp'``. See the `Perturbo website <https://perturbo-code.github.io/mydoc_interpolation#phonon-dispersioncalc_mode--phdisp>`_ for more details. The Perturbo calculation outputs a YAML file, which contains all the information about the inputs and outputs of the ``phdisp`` calculation, as well as data about the material from the *'prefix'_epr.h5*. You can also find information about the structure of the YAML file on the `Perturbo website <https://perturbo-code.github.io/mydoc_interpolation.html#phdisp_output_yaml>`_.

The YAML file used in this tutorial can be generated by following the `Perturbo tutorial <https://perturbo-code.github.io/mydoc_interpolation#phonon-dispersioncalc_mode--phdisp>`_. The input files for this tutorial can be found `here <https://caltech.app.box.com/s/dxtieunoz2rgdns08os6vmtsxckmytrz/folder/101108473635>`_. Alternatively, the pre-generated YAML file can be found `here <https://caltech.app.box.com/s/dxtieunoz2rgdns08os6vmtsxckmytrz/folder/101106141066>`_.

We first create a :py:class:`.PhdispCalcMode` object ``phdisp`` calculation, using the YAML file as an input. The ``phdisp`` object stores all the information from the YAML file.

.. code-block :: python

	import perturbopy.postproc as ppy

	si_bands = ppy.PhdispCalcMode.from_yaml('si_phdisp.yml')

The rest of this section is organized as follows. :ref:`First <Accessing the data>`, we explain how the data can be accessed from ``si_phdisp``. :ref:`Then <Plotting the phonon dispersion>`, we explain how to plot the phonon dispersion. 

Accessing the data
~~~~~~~~~~~~~~~~~~

The ``si_phdisp`` object contains the following information:

*  information about the material (the *basic data* section in the *si_bands.yml* file), such as the lattice parameter and lattice vectors. 
* inputs to the ``phdisp`` calculation (the *input parameters* section in the *si_phdisp.yml* file)
* outputs from the ``phdisp`` calculation (the *phdisp* section in the *si_phdisp.yml* file)

First, each entry of the *basic data* is stored in separate attributes in ``si_phdisp``. For example, here we obtain the lattice parameter (alat) and lattice vectors (lat) used for silicon:

.. code-block :: python

	si_bands.alat

	>> 10.264

	si_bands.lat

	>> array([[-0.5,  0. , -0.5],
              [ 0. ,  0.5,  0.5],
              [ 0.5,  0.5,  0. ]])

For full details on all the *basic data* entries stored as attributes in ``si_bands``, please refer to the parameters of :py:class:`.CalcMode`. Additionally, for details on accessing the *input parameters*, please refer to (link to API or documentation). 

The outputs of the calculation are stored in two the ``kpts`` attribute and ``bands`` attribute, described in more detail below.

K-points
--------
The ``kpts`` is a :py:class:`.RecipPtDB` that stores the k-point coordinates used in the calculation. The k-point coordinates are stored as a 3xN array in the :py:attr:`.BandsCalcMode.kpt` attribute. For example, to access the first k-point:

.. code-block :: python
	
	si_bands.kpt.points[:, 0]

	>> array([0.5, 0.5, 0.5])

The units of :py:attr:.RecipPtDB.points can either be:

* *crystal*: coordinates are in relative coordinates of the reciprocal lattice vectors
* *cartesian*: coordinates are in units of :math:`\frac{2\pi}{a}`

To see the units, 

.. code-block :: python
	
	si_bands.kpt.units

	>> 'crystal'

To change the units,

.. code-block :: python
	
	si_bands.kpt.convert_units("cartesian")
	si_bands.units

	>> 'cartesian'

The :py:attr:`.BandsCalcMode.kpt` attribute also stores the k-path coordinates, which are the one-dimensional coordinates assigned to each k-point to define the path taken through reciprocal space. These would be the x-coordinates on a plot of the band structure.

.. code-block :: python
	
	si_bands.kpt.path

	>> array([0., 0.0169809, 0.0339618, ... 3.7386444, 3.7594417, 3.780239])

It is also possible to rescale the k-path, which has arbitrary units.

.. code-block :: python
	
	# Rescale the k-path to a range between 0 and 10
	si_bands.kpt.scale_path(0, 10)

	si_bands.kpt.path

	>> array([0., 0.04492018,  0.08984035, ... 9.88996833,  9.94498417, 10.])

The :py:attr:`.BandsCalcMode.kpt` attribute also provides methods to:

* search an array of k-points for a particular k-point, and return the indices of the matches (:py:meth:`.RecipPtDB.find`)
* find the k-path coordinate corresponding to a k-point coordinate (:py:meth:`.RecipPtDB.point2path`)
* find the k-point coordinate corresponding to a k-path coordinate (:py:meth:`.RecipPtDB.path2point`)

.. code-block :: python

	# Finds the index or indices of the k-point [0.5, 0.25, 0.75]
	si_bands.kpt.find([0.5, 0.25, 0.75])

	>> array([123], dtype=int64)

	# Check that this index is correct
	si_bands.kpt.points[:, 123]

	>> array([0.5 , 0.25, 0.75])

	# Find the k-path coordinate corresponding to k-point [0.5, 0.25, 0.75]
	si_bands.kpt.point2path([0.5, 0.25, 0.75])

	>> array([6.25893072])

	# Check that this k-path coordinate is correct
	si_bands.kpt.path[123]

	>> 6.258930718401667

	# Do the reverse: convert from k-path coordinate to k-point 
	si_bands.kpt.path2point(6.25893072)

	>> array([0.5 , 0.25, 0.75])

Note that, in the case of repeated k-points, both indices will be returned:

.. code-block :: python

	# Find the index of the gamma point, which is in the k-points twice
	si_bands.kpt.find([0,0,0])

	>> array([ 51, 195], dtype=int64)

	# Check this result
	si_bands.kpt.points[:, 51]
	si_bands.kpt.points[:, 195]

	>> array([0., 0., 0.])
	   array([0., 0., 0.])


Note that all three of these functions take two additional inputs: `max_dist` and `nearest`. The `max_dist` (default 0.025) specifies the maximum distance between two k-points to consider them a match. For example, 

.. code-block :: python

	# Find the index of [0.01, 0.01, 0.01], which is not one of the k-points stored in kpt.points.
	# However, its distance from [0,0,0] is 0.017 < 0.025, so the results for [0, 0, 0] are returned.
	si_bands.kpt.find([0.01, 0.01, 0.01])

	>> array([ 51, 195], dtype=int64)

	# Check this result
	si_bands.kpt.points[:, 51]
	si_bands.kpt.points[:, 195]

	>> array([0., 0., 0.])
	>> array([0., 0., 0.])

If `nearest` (default True) is True, only the k-point(s) that are closest to a requested k-point is considered a match, even if other k-points are within the `max_dist` range. For example, if `max_dist` = 0.05, then both [0.01, 0.01, 0.01] and [0.02, 0.02, 0.02] lie within that distance from [0, 0, 0]. If `nearest` = True, only [0.01, 0.01, 0.01] is considered a match. If `nearest` is False, both are considered matches. 

We can also add labels to the k-points. For example, the FCC Brillouin zone identifies [0.5, 0.5, 0.5] as the L point, and [0.5, 0.0, 0.5] as the X point. To add these labels,

.. code-block :: python
	
	si_bands.kpt.add_labels({"L": [0.5, 0.5, 0.5], "X": [0.5, 0.0, 0.5]})
	si_bands.kpt.labels

	>> {'L': [0.5, 0.5, 0.5], 'X': [0.5, 0.0, 0.5]}

Note these labels can be removed with `kpt.remove_labels`.

.. code-block :: python

	si_bands.kpt.remove_labels(["L"])
	si_bands.kpt.labels

	>> {'X': [0.5, 0.0, 0.5]}

A dictionary of labels for the FCC lattice can be found in ``ppy.plot_tools.points_fcc``.

.. code-block :: python
	
	si_bands.kpt.add_labels(ppy.plot_tools.points_fcc)
	si_bands.kpt.labels

	>> {'L': [0.5, 0.5, 0.5],
	>>	'X': [0.5, 0.0, 0.5],
	>>	'W': [0.5, 0.25, 0.75],
	>>	'K': [0.375, 0.375, 0.75],
	>>	'$\\Gamma$': [0, 0, 0]}

For more details on the RecipPtDB and its attributes, see (link to API and/or documentation).

Energies
--------

The band energies are stored in the ``bands`` attribute, which is an (:py:class:`.EnergyDB`). The (:py:attr:`.EnergyDB.energies`) attribute is a dictionary, with keys corresponding to band index and values corresponding to the energies of that band along the k-point path. We can also access and convert the energy units.

.. code-block :: python

	si_bands.bands.energies.keys()
	>> dict_keys([1, 2, 3, 4, 5, 6, 7, 8])

	si_bands.bands.energies[8]
	>> array([13.69848506, 13.70154719, ..., 9.47676028, 9.46081004])

	si_bands.bands.units
	>> 'eV'

	# Units can be converted

	si_bands.bands.convert_units("Hartree")

For more details on the EnergyDB, (reference to API or documentation).


Plotting the band structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Perturbopy allows users to quickly plot the band structure with a few lines of code: 

.. code-block :: python

	import perturbopy.postproc as ppy
	import matplotlib.pyplot as plt

	fig, ax  = plt.subplots()

	si_bands = ppy.BandsCalcMode.from_yaml('si_bands.yml')

	si_bands.plot_bands(ax)

For a nicer plot, we can use the ``plotparams`` dictionary provided in the ``plot_tools`` module. We can also add k-point labels (link to the k-point section) so that these are automatically added to the plot. 

.. code-block :: python

	import perturbopy.postproc as ppy
	import matplotlib.pyplot as plt

	fig, ax  = plt.subplots()
	plt.rcParams.update(ppy.plot_tools.plotparams)

	si_bands = ppy.BandsCalcMode.from_yaml('si_bands.yml')
	si_bands.kpt.add_labels(ppy.plot_tools.points_fcc)

	si_bands.plot_bands(ax)

** check it **

.. image:: figures/silicon_bands.png
	:width: 450
	:align: center

Note that k-point labels can be removed from the plot by setting the ``show_labels`` input to False.

We can also change the energy window: 

.. code-block :: python

	si_bands.plot_bands(ax, energy_window=[2,12])

.. image:: figures/silicon_bands_window.png
	:width: 450
	:align: center

Other options include changing the linestyle and color.

.. code-block :: python

	si_bands.plot_bands(ax, c='b', ls='--')

.. image:: figures/silicon_bands_color_linestyle.png
	:width: 450
	:align: center
	
The colors and linestyles can also be a list.

.. code-block :: python

	si_bands.plot_bands(ax, c=['r','b','g','y'])

.. image:: figures/silicon_bands_colorful.png
	:width: 450
	:align: center

Explain using plot_tools directly?
