Bands tutorial
==============

In this section, we describe how to use Perturbopy to process a Perturbo ``bands`` calculation. 

The Perturbo ``bands`` calculation interpolates the band structure using Wannier functions. The first step is to run Perturbo with ``calc_mode`` = ``'bands'``. More details can be found on the `Perturbo website <https://perturbo-code.github.io/mydoc_interpolation#electronic-bandscalc_mode--bands>`_. The Perturbo calculation outputs a YAML file, which by default is called *pert_output.yml*. The YAML file contains all the information about the inputs and outputs of the ``bands`` calculation, as well as data about the material from the *'prefix'_epr.h5*. You can also find information about the structure of the YAML file on the `Perturbo website <https://perturbo-code.github.io/mydoc_interpolation#electronic-bandscalc_mode--bands>`_.

The YAML file used in this tutorial can be generated by following the `Perturbo tutorial <https://perturbo-code.github.io/mydoc_interpolation>`_. The input files for this tutorial can be found `here <https://caltech.app.box.com/s/dxtieunoz2rgdns08os6vmtsxckmytrz/folder/101106240180>`_. Alternatively, the pre-generated YAML file can be found `here <https://caltech.app.box.com/s/dxtieunoz2rgdns08os6vmtsxckmytrz/folder/101108632841>`_.

We first create a :py:class:`.BandsCalcMode` object containing the data from the ``bands`` calculation, using the YAML file as an input. The ``bands`` object contains all the information from the YAML file. 

.. code-block :: python

	import perturbopy.postproc as ppy

	si_bands = ppy.BandsCalcMode.from_yaml('si_bands.yml')

The rest of this section is organized as follows. :ref:`First <Accessing the data>`, we explain how the data can be accessed from ``si_bands``. :ref:`Then <Calculations>`, we explain how to perform calculations such as computing the direct bandgap, indirect bandgap, and effective mass. :ref:`Finally <Plotting the band structure>`, we explain how to plot the bands. 

Accessing the data
~~~~~~~~~~~~~~~~~~

The ``si_bands`` object contains the following information:
*  information about the material (the *basic data* section in the *si_bands.yml* file), such as the lattice parameter and lattice vectors. 
* inputs to the ``bands`` calculation (the *input parameters* section in the *si_bands.yml* file)
* outputs from the ``bands`` calculation (the *bands* section in the *si_bands.yml* file)

First, each entry of the *basic data* is stored in separate attributes in ``si_bands``. For example, here we obtain the lattice parameter (alat) and lattice vectors (lat) used for silicon:

.. code-block :: python

	si_bands.alat

	>> 10.264

	si_bands.lat

	>> array([[-0.5,  0. , -0.5],
              [ 0. ,  0.5,  0.5],
              [ 0.5,  0.5,  0. ]])

For full details on all the *basic data* entries stored as attributes in ``si_bands``, please refer to the parameters of :py:class:`.CalcMode`. Additionally, for details on accessing the *input parameters*, please refer to (link to API or documentation). 

The outputs of the calculation are stored in two the ``kpts`` attribute and ``bands`` attribute, described in more detail below.

K-points
--------
The ``kpts`` is a :py:class:`.RecipPtDB` that stores the k-point coordinates used in the calculation. The k-point coordinates are stored as a 3xN array in the :py:attr:`.BandsCalcMode.kpt` attribute. For example, to access the first k-point:

.. code-block :: python
	
	si_bands.kpt.points[:, 0]

	>> array([0.5, 0.5, 0.5])

** make bullet points work**

The units of ``kpt.points`` can either be:
* ``crystal``: coordinates are in relative coordinates of the reciprocal lattice vectors
* ``cartesian``: coordinates are in units of :math:`\frac{2\pi}{a}`

To see the units, 

.. code-block :: python
	
	si_bands.kpt.units

	>> 'crystal'

To change the units,

.. code-block :: python
	
	si_bands.kpt.convert_units("cartesian")
	si_bands.units

	>> 'cartesian'

The :py:attr:`.BandsCalcMode.kpt` attribute also stores the k-path coordinates, which are the one-dimensional coordinates assigned to each k-point to define the path taken through reciprocal space. These would be the x-coordinates on a plot of the band structure.

.. code-block :: python
	
	si_bands.kpt.path

	>> array([0., 0.0169809, 0.0339618, ... 3.7386444, 3.7594417, 3.780239])

It is also possible to rescale the k-path, which has arbitrary units.

.. code-block :: python
	
	# Rescale the k-path to a range between 0 and 10
	si_bands.kpt.scale_path(0, 10)

	si_bands.kpt.path

	>> array([0., 0.04492018,  0.08984035, ... 9.88996833,  9.94498417, 10.])

The :py:attr:`.BandsCalcMode.kpt` attribute also provides methods to:

* search an array of k-points for a particular k-point, and return the indices of the matches (:py:meth:`.RecipPtDB.find`)
* find the k-path coordinate corresponding to a k-point coordinate (:py:meth:`.RecipPtDB.point2path`)
* find the k-point coordinate corresponding to a k-path coordinate (:py:meth:`.RecipPtDB.path2point`)

.. code-block :: python

	# Finds the index or indices of the k-point [0.5, 0.25, 0.75]
	si_bands.kpt.find([0.5, 0.25, 0.75])

	>> array([123], dtype=int64)

	# Check that this index is correct
	si_bands.kpt.points[:, 123]

	>> array([0.5 , 0.25, 0.75])

	# Find the k-path coordinate corresponding to k-point [0.5, 0.25, 0.75]
	si_bands.kpt.point2path([0.5, 0.25, 0.75])

	>> array([6.25893072])

	# Check that this k-path coordinate is correct
	si_bands.kpt.path[123]

	>> 6.258930718401667

	# Do the reverse: convert from k-path coordinate to k-point 
	si_bands.kpt.path2point(6.25893072)

	>> array([0.5 , 0.25, 0.75])

** change the tolerance for the last example (si_bands.kpt.path2point(6.25893072))**

Note that, in the case of repeated k-points, both indices will be returned:

.. code-block :: python

	# Find the index of the gamma point, which is in the k-points twice
	si_bands.kpt.find([0,0,0])

	>> array([ 51, 195], dtype=int64)

	# Check this result
	si_bands.kpt.points[:, 51]
	si_bands.kpt.points[:, 195]

	>> array([0., 0., 0.])
	   array([0., 0., 0.])


Note that all three of these functions take two additional inputs: `max_dist` and `nearest`. The `max_dist` (default 0.025) specifies the maximum distance between two k-points to consider them a match. For example, 

** check the outputs and check if the code is correct **

.. code-block :: python

	# Find the index of [0.01, 0.01, 0.01], which is not one of the k-points stored in kpt.points.
	# However, its distance from [0,0,0] is 0.017 < 0.025, so the results for [0, 0, 0] are returned.
	si_bands.kpt.find([0.01, 0.01, 0.01])

	>> array([ 51, 195], dtype=int64)

	# Check this result
	si_bands.kpt.points[:, 51]
	si_bands.kpt.points[:, 195]

	>> array([0., 0., 0.])
	>> array([0., 0., 0.])

If `nearest` (default True) is True, only the k-point(s) that are closest to a requested k-point is considered a match, even if other k-points are within the `max_dist` range. For example, if `max_dist` = 0.05, then both [0.01, 0.01, 0.01] and [0.02, 0.02, 0.02] lie within that distance from [0, 0, 0]. If `nearest` = True, only [0.01, 0.01, 0.01] is considered a match. If `nearest` is False, both are considered matches. 

We can also add labels to the k-points. For example, the FCC Brillouin zone identifies [0.5, 0.5, 0.5] as the L point, and [0.5, 0.0, 0.5] as the X point. To add these labels,

.. code-block :: python
	
	si_bands.kpt.add_labels({"L": [0.5, 0.5, 0.5], "X": [0.5, 0.0, 0.5]})
	si_bands.kpt.labels

	>> {'L': [0.5, 0.5, 0.5], 'X': [0.5, 0.0, 0.5]}

Note these labels can be removed with `kpt.remove_labels`.

.. code-block :: python

	si_bands.kpt.remove_labels(["L"])
	si_bands.kpt.labels

	>> {'X': [0.5, 0.0, 0.5]}

A dictionary of labels for the FCC lattice can be found in ``ppy.plot_tools.points_fcc``.

.. code-block :: python
	
	si_bands.kpt.add_labels(ppy.plot_tools.points_fcc)
	si_bands.kpt.labels

	>> {'L': [0.5, 0.5, 0.5],
	>>	'X': [0.5, 0.0, 0.5],
	>>	'W': [0.5, 0.25, 0.75],
	>>	'K': [0.375, 0.375, 0.75],
	>>	'$\\Gamma$': [0, 0, 0]}

For more details on the RecipPtDB and its attributes, see (link to API and/or documentation).

Energies
--------

The band energies are stored in the ``bands`` attribute, which is an (:py:class:`.EnergyDB`). The (:py:attr:`.EnergyDB.energies`) attribute is a dictionary, with keys corresponding to band index and values corresponding to the energies of that band along the k-point path. We can also access and convert the energy units.

.. code-block :: python

	si_bands.bands.energies.keys()
	>> dict_keys([1, 2, 3, 4, 5, 6, 7, 8])

	si_bands.bands.energies[8]
	>> array([13.69848506, 13.70154719, ..., 9.47676028, 9.46081004])

	si_bands.bands.units
	>> 'eV'

	# Units can be converted

	si_bands.bands.convert_units("Hartree")

**fix si_bands.bands.convert_units("Hartree")**

For more details on the EnergyDB, (reference to API or documentation).


Calculations
~~~~~~~~~~~~

Direct bandgap
--------------

The direct bandgap is the difference between the valence band maximum (VBM) and the condunction band minimum (CBM), for which the k-vectors are the same. For example, to compute the direct bandgap in silicon between the valence band (band index 4) and conduction band (band index 5), we call the ``direct_bandgap`` method with the two band indices as inputs:

.. code-block :: python
	
	# Compute the direct bandgap between bands 4 and 5
	si_bands.direct_bandgap(4,5)

	>> (2.513629987199999, array([0., 0., 0.]))

The ``direct_bandgap`` method returns the bandgap, 2.51 eV, and the k-point at which that direct bandgap occurs, [0, 0, 0]. Note that silicon is an indirect bandgap material, so this is not the minimal energy difference between the valence band and conduction band.

Indirect bandgap
----------------

The indirect bandgap is the difference between VBM and CBM, without the same k-vector constraint. For example, to compute the indirect bandgap in silicon between the valence band and conduction band, we call the ``indirect_bandgap`` **link** method with the two band indices as inputs:

.. code-block :: python

	# Compute the indirect bandgap between bands 4 and 5
	si_bands.indirect_bandgap(4,5)

	>> (0.4577520852000001, array([0., 0., 0.]), array([0.43137, 0.     , 0.43137]))

The ``indirect_bandgap`` method returns the bandgap, 0.458 eV, the k-point of VBM is [0, 0, 0], and the k-point of CBM is [0.43137, 0.     , 0.43137].

Effective mass
--------------

The effective mass is computed in the parabolic approximation from the curvature of the parabola. 

** insert an equation in math mode **

We can compute the effective mass of a carrier at band index ``n`` and k-point ``kpoint`` in the direction of the ``direction`` input. If no direction is provided, the longitudinal effective mass will be computed (i.e. the direction will be the same as the kpoint). Note that a direction must be provided if the k-point is [0, 0, 0]. 

Another important input is ``max_distance``, which is the maximum distance from the central k-point to other k-points included in the calculation. For example, let's compute the longitudinal effective mass at [0.43, 0., 0.43], which is the CBM of silicon. We will use ``max_distance`` of 0.12. The experimental value is ~0.98 me **use math mode?**. 

.. code-block :: python

	# Compute the effective mass of an electron at band 5, k-point [0.43, 0, 0.43]
	# by a parabolic approximation that includes longitudinal k-points at a max
	# distance of 0.12 from [0.43, 0, 0.43]
	si_bands.effective_mass(5, [0.43, 0, 0.43], max_distance=0.12) 
	
	>> 0.9714141122114681

If an axis is provided, the band structure will be plotted, as well as the points chosen for the effective mass calculation and a dashed line reflecting the parabolic approximation (with a color specified by input ``c``). Let's plot the previous result.

.. code-block :: python

	import matplotlib.pyplot as plt

	fig, ax = plt.subplots()

	plt.rcParams.update(ppy.plot_tools.plotparams)

	si_bands.effective_mass(5, [0.43, 0, 0.43], max_distance=0.12, ax=ax) 
	
	>> 0.9714141122114681

.. image:: figures/silicon_el_effective_mass.png
	:width: 450
	:align: center

The plot shows the bands, with the points selected for the approximation plotted in red. Note that the points and line of fit stop at the "X" point because past here, the effective mass is no longer longitudinal.

We can zoom in to see the parabolic fit better. The dashed line is the parabolic fit, and extends past the points.

.. image:: figures/silicon_el_effective_mass_zoom.png
	:width: 400
	:align: center

To increase the number of points used in the calculation, we should increase max_dist.

Next, let's compute the effective mass for holes at the VBM (n=4, kpoint=[0, 0, 0]) in the [0.5, 0.5, 0.5] direction and [0.5, 0, 0.5] directions, which are the left and right effective masses, respectively. Note that, because this is a hole, we expect the effective mass to be negative. 

.. code-block :: python

	m_left = si_bands.effective_mass(4, [0, 0, 0], max_distance=0.1, direction=[0.5, 0.5, 0.5], ax=ax, c="r")
	m_right = si_bands.effective_mass(4, [0, 0, 0], max_distance=0.1, direction=[0.5, 0, 0.5], ax=ax, c="b")
	
	m_left
	m_right

	plt.show()

	>> -0.7826178453262155
	>> -0.3391250154182139

.. image:: figures/silicon_hole_effective_mass.png
	:width: 450
	:align: center

** why there are two blue dahsed lines?**

Plotting the band structure
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Perturbopy allows users to quickly plot the band structure with a few lines of code: 

.. code-block :: python

	import perturbopy.postproc as ppy
	import matplotlib.pyplot as plt

	fig, ax  = plt.subplots()

	si_bands = ppy.BandsCalcMode.from_yaml('si_bands.yml')

	si_bands.plot_bands(ax)

For a nicer plot, we can use the ``plotparams`` dictionary provided in the ``plot_tools`` module. We can also add k-point labels (link to the k-point section) so that these are automatically added to the plot. 

.. code-block :: python

	import perturbopy.postproc as ppy
	import matplotlib.pyplot as plt

	fig, ax  = plt.subplots()
	plt.rcParams.update(ppy.plot_tools.plotparams)

	si_bands = ppy.BandsCalcMode.from_yaml('si_bands.yml')
	si_bands.kpt.add_labels(ppy.plot_tools.points_fcc)

	si_bands.plot_bands(ax)

** check it **

.. image:: figures/silicon_bands.png
	:width: 450
	:align: center

Note that k-point labels can be removed from the plot by setting the ``show_labels`` input to False.

We can also change the energy window: 

.. code-block :: python

	si_bands.plot_bands(ax, energy_window=[2,12])

.. image:: figures/silicon_bands_window.png
	:width: 450
	:align: center

Other options include changing the linestyle and color.

.. code-block :: python

	si_bands.plot_bands(ax, c='b', ls='--')

.. image:: figures/silicon_bands_color_linestyle.png
	:width: 450
	:align: center
	
The colors and linestyles can also be a list.

.. code-block :: python

	si_bands.plot_bands(ax, c=['r','b','g','y'])

.. image:: figures/silicon_bands_colorful.png
	:width: 450
	:align: center

Explain using plot_tools directly?
